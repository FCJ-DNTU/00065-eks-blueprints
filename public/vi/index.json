[
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Bài lab sử dụng các template và quá trình sao chép mã có thể xảy ra lỗi. Tham khảo Repository để chỉnh sửa nếu gặp lỗi\nEKS Blueprints EKS Blueprints là một khung mã nguồn mở (open-source development framework) tóm tắt sự phức tạp của cơ sở hạ tầng đám mây từ các nhà phát triển và cho phép họ triển khai workloads một cách dễ dàng.\nMôi trường được chứa trong container trên AWS bao gồm nhiều sản phẩm và dịch vụ AWS hoặc mã nguồn mở, bao gồm các dịch vụ để chạy container, CI/CD pipeline, ghi nhật ký/số liệu và các biện pháp thực thi bảo mật.\nEKS Blueprints framework đóng gói các công cụ này thành một tổng thể gắn kết và cung cấp chúng cho các nhóm phát triển như một dịch vụ. Từ góc độ hoạt động, khuôn khổ cho phép các công ty hợp nhất các công cụ và thực tiễn tốt nhất để bảo mật, mở rộng quy mô, giám sát và vận hành cơ sở hạ tầng container thành một nền tảng trung tâm mà sau đó các nhà phát triển trong một doanh nghiệp có thể sử dụng.\nHoạt động EKS Blueprints được xây dựng dựa trên Amazon EKS và tất cả các thành phần khác nhau. EKS Blueprints được định nghĩa thông qua các phương pháp hay nhất về Cơ sở hạ tầng dưới dạng mã (Infrastructre-as-Code) thông qua AWS CDK.\nXem thêm tài liệu về EKS blueprints dành cho CDK được xây dựng bằng AWS CDK giúp khách hàng dễ dàng xây dựng và triển khai EKS blueprints trên Amazon EKS .\nAWS Cloud Development Kit (AWS CDK) là một khung phát triển phần mềm mã nguồn mở để xác định tài nguyên ứng dụng đám mây bằng các ngôn ngữ lập trình quen thuộc.\nLợi ích Khách hàng có thể tận dụng EKS Blueprints để:\nTriển khai các cluster EKS trên bất kỳ số lượng tài khoản và khu vực nào theo các phương pháp hay nhất.\nQuản lý cấu hình cluster, bao gồm các tiện ích bổ sung chạy trong mỗi cluster, từ một kho lưu trữ Git.\nXác định nhóm, không gian tên và quyền truy cập liên quan của họ cho các nhóm của bạn.\nTạo các Continuous Delivery (CD) pipeline chịu trách nhiệm triển khai cơ sở hạ tầng của bạn.\nTận dụng GitOps-based workflows để giới thiệu và quản lý workload cho nhóm của bạn.\nCác Construct của EKS Blueprints:\nBottlerocket AWS Fargate Multi-region deployments Multi-team deployments Custom cluster deployments "
},
{
	"uri": "//localhost:1313/vi/7-add-ons/7.1-intro/",
	"title": "Giới thiệu add-ons",
	"tags": [],
	"description": "",
	"content": " Thêm một add-on vào template đơn giản như thêm phương thức .addOns vào blueprints.EksBlueprint.builder(). Chúng ta sẽ sử dụng Cluster Autoscaler làm ví dụ để cho thấy việc add-ons sử dụng EKS Blueprint đơn giản như thế nào. Thêm Cluster Autoscaler vào template lib/pipeline.ts của bạn như được hiển thị bên dưới: // lib/pipeline.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport { Construct } from \u0026#39;constructs\u0026#39;;\rimport * as blueprints from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rimport { KubernetesVersion } from \u0026#39;aws-cdk-lib/aws-eks\u0026#39;;\rimport { TeamApplication, TeamPlatform } from \u0026#39;../teams\u0026#39;;\rexport default class PipelineConstruct extends Construct {\rconstructor(scope: Construct, id: string, props?: cdk.StackProps) {\rsuper(scope, id)\rconst account = props?.env?.account!;\rconst region = props?.env?.region!;\rconst blueprint = blueprints.EksBlueprint.builder()\r.account(account)\r.region(region)\r.clusterProvider(\rnew blueprints.GenericClusterProvider({\rversion: \u0026#39;auto\u0026#39;,\r})\r)\r.addOns(new blueprints.ClusterAutoScalerAddOn) // Cluster Autoscaler addon goes here\r.teams(new TeamPlatform(account), new TeamApplication(\u0026#39;burnham\u0026#39;, account));\rblueprints.CodePipelineStack.builder()\r.name(\u0026#34;eks-blueprints-workshop-pipeline\u0026#34;)\r.owner(\u0026#34;FromSunNews\u0026#34;)\r.repository({\rrepoUrl: \u0026#39;my-eks-blueprints\u0026#39;,\rcredentialsSecretName: \u0026#39;eks-workshop-token\u0026#39;,\rtargetRevision: \u0026#39;main\u0026#39;\r})\r.wave({\rid: \u0026#34;envs\u0026#34;,\rstages: [\r{ id: \u0026#34;dev\u0026#34;, stackBuilder: blueprint.clone(\u0026#39;ap-southeast-1\u0026#39;) }\r]\r})\r.build(scope, id + \u0026#39;-stack\u0026#39;, props);\r}\r} Nếu bạn chưa quen với Cluster Autoscaler, đây là một công cụ tự động điều chỉnh số lượng node trong cluster của bạn khi các pod bị lỗi do không đủ tài nguyên hoặc các pod được lên lịch lại cho các node khác do không được sử dụng hết trong một khoảng thời gian dài. Push các thay đổi của bạn vào repo GitHub của bạn để bắt đầu quy trình. git add .\rgit commit -m \u0026#34;adding CA\u0026#34;\rgit push https://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@github.com/AWS-First-Cloud-Journey/my-eks-blueprints.git Đợi khoảng 15 phút sẽ hoàn thành. Sau đó, chạy lệnh sau để kiểm tra Cluster Autoscaler đang chạy kubectl get pods -n kube-system "
},
{
	"uri": "//localhost:1313/vi/8-deploy/8.1-argocd/",
	"title": "Giới thiệu ArgoCD",
	"tags": [],
	"description": "",
	"content": "Giới thiệu ArgoCD Bước tiếp theo là sử dụng ArgoCD để tăng workload của nhóm chúng ta. Có hai cách để tận dụng ArgoCD với EKS Blueprints:\nTích hợp workload onboarding thủ công bằng ArgoCD CLI và hiển thị ArgoCD server cục bộ để có quyền truy cập vào bảng điều khiển\nTận dụng bootstrapping tự động để tự động hóa việc tích hợp workload của bạn.\nCD Argo là một công cụ phân phối liên tục, mang tính khai báo GitOps cho Kubernetes. Các điều khoản bổ sung Argo CD vào một cluster EKS và có thể tùy chọn khởi động khối lượng công việc của bạn từ các kho lưu trữ Git công khai và riêng tư.\nTiện ích bổ sung Argo CD cho phép quản trị viên nền tảng kết hợp cung cấp cluster và khởi động khối lượng công việc trong một bước duy nhất và cho phép các trường hợp sử dụng như sao chép một cluster sản xuất đang chạy hiện có ở một khu vực khác trong vài phút. Điều này rất quan trọng đối với tính liên tục của hoạt động kinh doanh và các trường hợp khắc phục thảm họa cũng như tính khả dụng giữa các khu vực và mở rộng địa lý.\nArgoCD cho EKS Blueprints ArgoCD phù hợp tốt với các nguyên tắc xác định đề xuất giá trị của việc sử dụng Bản thiết kế EKS, bao gồm:\nCác định nghĩa, cấu hình và môi trường ứng dụng phải được khai báo và kiểm soát phiên bản Việc triển khai ứng dụng và quản lý vòng đời phải được tự động hóa, có thể kiểm tra được và dễ hiểu Tuân theo mô hình GitOps sử dụng kho lưu trữ Git như một chân lý để xác định trạng thái ứng dụng mong muốn của bạn Tính linh hoạt về cách Kubernetes biểu hiện được xác định và quản lý Argo CD tự động hóa việc triển khai các trạng thái ứng dụng mong muốn trong các môi trường đích được chỉ định. Việc triển khai ứng dụng có thể theo dõi các bản cập nhật cho các nhánh, thẻ hoặc được ghim vào một phiên bản tệp kê khai cụ thể tại một cam kết Git. Argo CD được thực hiện như một bộ điều khiển Kubernetes liên tục theo dõi các ứng dụng đang chạy và so sánh trạng thái hiện tại, trực tiếp với trạng thái mục tiêu mong muốn (như được chỉ định trong Git repo). Ứng dụng đã triển khai có trạng thái trực tiếp lệch khỏi trạng thái đích được coi là OutOfSync. Argo CD báo cáo \u0026amp; trực quan hóa sự khác biệt, đồng thời cung cấp các phương tiện để tự động hoặc thủ công đồng bộ hóa trạng thái trực tiếp trở lại trạng thái mục tiêu mong muốn. Bất kỳ sửa đổi nào được thực hiện đối với trạng thái mục tiêu mong muốn trong kho Git có thể được tự động áp dụng và phản ánh trong các môi trường mục tiêu được chỉ định.\nArgoCD Bootstrapping EKS Blueprints cung cấp cách tiếp cận bootstrap workload và add-ons từ customer GitOps repository.\nBạn xem thêm tài liệu Cluster Bootstrapping\nĐể cho phép bootstrapping, ArgoCD add-on cho phép chuyển một ApplicationRepository thời điểm xây dựng. Hiện tại hỗ trợ các loại repository sau:\nPublic HTTP/HTTPS repository (ví dụ: GitHub) Git repository truy cập Private HTTPS yêu cầu xác thực tên người dùng / mật khẩu. Private git repository với quyền truy cập SSH yêu cầu SSH key để xác thực. GitHub repository có thể truy cập Private HTTPS có thể truy cập được bằng GitHub token. "
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Session Management",
	"tags": [],
	"description": "",
	"content": "Giới thiệu về EKS Blueprints Sơ đồ kiến trúc Khái niệm cốt lõi Concepts Description Cluster An EKS Cluster deployed following best practices. Resource Provider Resource providers are abstractions that supply external AWS resources to the cluster (e.g. hosted zones, VPCs, etc.). Add-on Allow you to configure, deploy, and update the operational software, or add-ons, that provide key functionality to support your Kubernetes applications. Teams A logical grouping of IAM identities that have access to a Kubernetes namespace(s), or cluster administrative access depending upon the team type. Pipelines Continuous Delivery pipelines for deploying clusters and add-ons Application An application that runs within an EKS Cluster. Blueprint EKS Blueprints cho phép bạn định cấu hình và triển khai những gì gọi là blueprint cluster. Blueprint kết hợp các cluster, tiện ích bổ sung và nhóm thành một đối tượng gắn kết có thể được triển khai tổng thể. Sau khi blueprint được định cấu hình, nó có thể được triển khai dễ dàng trên bất kỳ số lượng tài khoản AWS và khu vực nào. Blueprints cũng tận dụng công cụ GitOps để tạo điều kiện khởi động cluster và tích hợp workload.\nNội dung Giới thiệu Các bước chuẩn bị Tạo EKS Blueprints Tạo CDK Project Triển khai Pipeline Onboard Teams Add-ons Triển khai Dọn dẹp tài nguyên "
},
{
	"uri": "//localhost:1313/vi/5-deploymentpipeline/5.1-createacluster/",
	"title": "Tạo Cluster",
	"tags": [],
	"description": "",
	"content": "Tạo Cluster Trong phần này, chúng ta sẽ triển khai EKS cluster đầu tiên của mình bằng cách sử dụng eks-blueprints package. Blueprints được xuất bản dưới dạng mô-đun npm\nBạn có thể tìm hiểu thêm về Amazon EKS Blueprints for CDK\nChúng ta thực hiện chỉnh sửa main file của lib/my-eks-blueprints-stack.ts:\nMở file lib/my-eks-blueprints-stack.ts Xem các code mẫu trong file Thực hiện hoàn thành file lib/my-eks-blueprints-stack.ts bằng cách dán(thay thể) đoạn code sau vào file: // lib/my-eks-blueprints-stack.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport { Construct } from \u0026#39;constructs\u0026#39;;\rimport * as blueprints from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rimport { KubernetesVersion } from \u0026#39;aws-cdk-lib/aws-eks\u0026#39;;\rexport default class ClusterConstruct extends Construct {\rconstructor(scope: Construct, id: string, props?: cdk.StackProps) {\rsuper(scope, id);\rconst account = props?.env?.account!;\rconst region = props?.env?.region!;\rconst blueprint = blueprints.EksBlueprint.builder()\r.account(account)\r.region(region)\r.clusterProvider(\rnew blueprints.GenericClusterProvider({\rversion: \u0026#39;auto\u0026#39;\r})\r)\r.addOns()\r.teams()\r.build(scope, id + \u0026#34;-stack\u0026#34;);\r}\r} 3. Chúng ta mở file bin/my-eks-blueprints.ts để xem code mẫu.\n4. Trong tệp này, chúng ta tạo CDK Construct là building block của CDK thể hiện những thứ cần thiết để tạo nên các thành phần của AWS Cloud.\nTrong trường hợp của chúng ta, thành phần là EKS cluster blueprint đặt trong provided account, region, add-ons, teams (mà chúng ta chưa assign) và tất cả các tài nguyên khác cần thiết để tạo blueprint(ví dụ VPC, subnet,…). Lệnh build() ở cuối khởi tạo cluster blueprint.\nĐể thực sự làm cho một construct có thể sử dụng được trong CDK project, chúng ta cần thêm nó vào entrypoint của chúng ta.\nThay thế nội dung của bin/my-eks-blueprints.ts bằng code block sau.\n// bin/my-eks-blueprints.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport ClusterConstruct from \u0026#39;../lib/my-eks-blueprints-stack\u0026#39;;\rimport * as dotenv from \u0026#39;dotenv\u0026#39;;\rconst app = new cdk.App();\rconst account = process.env.CDK_DEFAULT_ACCOUNT!;\rconst region = process.env.CDK_DEFAULT_REGION;\rconst env = { account, region }\rnew ClusterConstruct(app, \u0026#39;cluster\u0026#39;, { env }); Chúng ta tạo mới một file .env Thêm biên môi trường vào\nCDK_DEFAULT_ACCOUNT=XXXXX\rCDK_DEFAULT_REGION=XXXX Hãy thay thế bằng CDK_DEFAULT_ACCOUNT và CDK_DEFAULT_REGION của bạn\nTệp import Construct để làm cho nó có sẵn, sau đó sử dụng CDK app để khởi tạo một object mới của CDK Construct mà chúng ta đã import. Kiểm tra CDK cdk list Nếu không có vấn đề, chúng ta có kết quả sau: cluster-stack Như bạn có thể thấy, chúng ta có thể tận dụng EksBlueprint để xác định cluster của chúng ta một cách dễ dàng bằng cách sử dụng CDK.\nThay vì triển khai single cluster, chúng ta sẽ tận dụng trình tạo blueprint để thêm deployment pipeline có thể xử lý tất cả các bản cập nhật cho cơ sở hạ tầng của chúng ta cho các môi trường khác nhau.\n"
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.1-createvpcec2/",
	"title": "Tạo VPC và EC2 Instance",
	"tags": [],
	"description": "",
	"content": "Tạo VPC Truy cập AWS Management Console\nTìm VPC Chọn Create VPC Trong giao diện VPC settings\nResources to create, chọn VPC and more Name tag auto-generation, nhập EKS Blueprint VPC IPv4 CIDR block, nhập 10.0.0.0/16 Chọn các AZs Chọn các AZs theo hình và bấm chọn Create VPC Sau khi tạo xong, chúng ta sẽ có một VPC như thế này Tạo EC2 Instance Truy cập AWS Management Console\nTìm EC2 Chọn Launch Instance Trong giao diện Launch an instance\nName and tags, chọn EKS Blueprint Instance Ở mục Application and OS Images (Amazon Machine Image)\nChọn Amazon Linux 2023 AMI Ở mục Instance type và Key pair\nChọn t3.small Tạo ra 1 key pair đặt tên là kp-eks-blueprint Ở mục Network settings\nChọn VPC mà bạn mới tạo Chọn public-subnet-1 Bật Auto-assign public IP Tạo một Security Group Ở mục Configure storage thay đổi bộ nhớ thành 30GB va nhấn Launch Instance Vậy là chúng ta đã hoàn thành việc khởi tạo EC2 Instance. "
},
{
	"uri": "//localhost:1313/vi/6-onboardteams/6.1-definingteams/",
	"title": "Thiết lập các nhóm",
	"tags": [],
	"description": "",
	"content": "Thiết lập các nhóm Thực hiện tạo các thư mục là các team gồm: application và platform. mkdir teams \u0026amp;\u0026amp; cd teams \u0026amp;\u0026amp; mkdir platform-team \u0026amp;\u0026amp; mkdir application-team Chúng ta sẽ bắt đầu bằng cách tạo một IAM user cho platform. aws iam create-user --user-name platform Tạo một file index.ts, dùng để tạo ressource cho platform-team cd platform-team \u0026amp;\u0026amp; touch index.ts Tiếp theo chúng ta thêm code block sau vào index.ts import { ArnPrincipal } from \u0026#34;aws-cdk-lib/aws-iam\u0026#34;;\rimport { PlatformTeam } from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rexport class TeamPlatform extends PlatformTeam {\rconstructor(accountID: string) {\rsuper({\rname: \u0026#34;platform\u0026#34;,\rusers: [new ArnPrincipal(`arn:aws:iam::${accountID}:user/platform`)]\r})\r}\r} Giải thích đoạn code block:\nCode block ở trên nhập ArnPrincipal construct từ mô-đun aws-cdk-lib/aws-iam cho AWS CDK để có thể thêm người dùng vào platform bằng thông tin đăng nhập IAM của họ.\nCách tốt nhất là mở rộng một class bằng cách sử dụng PlatformTeam class để những người thuộc platform/infrastucture của chúng ta có thể quản lý users/roles, trong khi các developer có thể chỉ cần tạo group bằng cách sử dụng các arugments được truyền vào.\nSau đó, chúng ta chuyển vào hai arugment: name và danh sách IAM user.\nApplication Team Thực hiện tạo IAM user cho application team. aws iam create-user --user-name application Thay đổi đường dẫn thư mục và tạo file index.ts cd ../application-team \u0026amp;\u0026amp; touch index.ts Thêm code vào teams/application-team/index.ts file import { ArnPrincipal } from \u0026#39;aws-cdk-lib/aws-iam\u0026#39;;\rimport { ApplicationTeam } from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rexport class TeamApplication extends ApplicationTeam {\rconstructor(name: string, accountID: string) {\rsuper({\rname: name, users: [new ArnPrincipal(`arn:aws:iam::${accountID}:user/application`)] });\r}\r} Application Team template sẽ thực hiện những việc sau:\nTạo một namespace Register quotas Đăng ký người dùng IAM để truy cập nhiều tài khoản Tạo một role được chia sẻ để truy cập cluster. Ngoài ra, một role hiện có có thể được cung cấp. Đăng ký role/user được cung cấp trong awsAuth map để truy cập kubectl và bảng điều khiển vào cluster và namespace. Chúng ta sẽ tạo thêm file index.ts trong thư mục team cd .. \u0026amp;\u0026amp; touch index.ts Trong file index.ts thêm code sau vào: export { TeamPlatform } from \u0026#39;./platform-team\u0026#39;;\rexport { TeamApplication } from \u0026#39;./application-team\u0026#39;; "
},
{
	"uri": "//localhost:1313/vi/8-deploy/8.2-deploy/",
	"title": "Triển khai với ArgoCD",
	"tags": [],
	"description": "",
	"content": "Triển khai Workload với ArgoCD Định nghĩa workload repo ArgoCD Bootstrapping bắt đầu bằng việc xác định các biến với thông tin repo như URL của repo chứa workload và đường dẫn trong ứng dụng của các ứng dụng. Chúng ta sẽ sử dụng phiên bản nhỏ hơn của ứng dụng. Ví dụ full-scale của ứng dụng có chứa workload cho team-burnham:\nconst repoUrl = \u0026#39;https://github.com/aws-samples/eks-blueprints-workloads.git\u0026#39;\rconst bootstrapRepo : blueprints.ApplicationRepository = {\rrepoUrl,\rtargetRevision: \u0026#39;workshop\u0026#39;,\r} Các bạn xem thêm EKS Blueprints Workloads\nĐịnh nghĩa ArgoCD add-on Sau đó, các biến có thể được chuyển như một tham số trong các định nghĩa ArgoCD add-on cho stage của chúng ta. Theo tùy chọn, bạn có thể đặt secret cho quản trị viên Argo.\nconst prodBootstrapArgo = new blueprints.ArgoCDAddOn({\rbootstrapRepo: {\r...bootstrapRepo,\rpath: \u0026#39;envs/dev\u0026#39;\r},\r}); Bạn có thể đặt các đường dẫn khác nhau từ repo dựa trên môi trường mà bạn đang làm việc. Vì đường dẫn của chúng ta có triển khai dev, test và prod, nên chúng ta có thể đặt đường dẫn đến ’envs / dev’, ’envs / test’ và ’env / prod’, đồng thời đặt các biến thành các tên riêng biệt.\nSau đó, chúng ta có thể chuyển thông tin này đến đường dẫn bằng cách sử dụng phương pháp addOns như một phần của thuộc tính stackBuilder thúc đẩy kế hoạch chi tiết của blueprints.\nblueprints.CodePipelineStack.builder()\r.name(\u0026#34;pipeline-name\u0026#34;)\r.owner(\u0026#34;owner-name\u0026#34;)\r.repository({\rrepoUrl: \u0026#39;repo-name\u0026#39;,\rcredentialsSecretName: \u0026#39;github-token\u0026#39;,\rtargetRevision: \u0026#39;main\u0026#39;\r})\r.wave({\rid: \u0026#39;envs\u0026#39;,\rstages: [\r{ id: \u0026#34;dev\u0026#34;, stackBuilder: blueprint.clone(\u0026#39;ap-southeast-1\u0026#39;).addOns(devBootstrapArgo)}\r]\r})\r.build(app, \u0026#39;pipeline-stack\u0026#39;); Thực hiện thay đổi file lib/pipeline-stack.ts // lib/pipeline-stack.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport { Construct } from \u0026#39;constructs\u0026#39;;\rimport * as blueprints from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rimport { TeamPlatform, TeamApplication } from \u0026#39;../teams\u0026#39;; export default class PipelineConstruct extends Construct {\rconstructor(scope: Construct, id: string, props?: cdk.StackProps){\rsuper(scope,id)\rconst account = props?.env?.account!;\rconst region = props?.env?.region!;\rconst blueprint = blueprints.EksBlueprint.builder()\r.account(account)\r.region(region)\r.addOns(\rnew blueprints.ClusterAutoScalerAddOn,\rnew blueprints.KubeviousAddOn(), ) .teams(new TeamPlatform(account), new TeamApplication(\u0026#39;burnham\u0026#39;,(account)));\r// HERE WE ADD THE ARGOCD APP OF APPS REPO INFORMATION\rconst repoUrl = \u0026#39;https://github.com/aws-samples/eks-blueprints-workloads.git\u0026#39;;\rconst bootstrapRepo : blueprints.ApplicationRepository = {\rrepoUrl,\rtargetRevision: \u0026#39;workshop\u0026#39;,\r}\r// HERE WE GENERATE THE ADDON CONFIGURATIONS\rconst devBootstrapArgo = new blueprints.ArgoCDAddOn({\rbootstrapRepo: {\r...bootstrapRepo,\rpath: \u0026#39;envs/dev\u0026#39;\r},\r});\rblueprints.CodePipelineStack.builder()\r.name(\u0026#34;eks-blueprints-workshop-pipeline\u0026#34;)\r.owner(\u0026#34;your-github-username\u0026#34;)\r.repository({\rrepoUrl: \u0026#39;your-repo-name\u0026#39;,\rcredentialsSecretName: \u0026#39;github-token\u0026#39;,\rtargetRevision: \u0026#39;main\u0026#39;\r})\r.wave({\rid: \u0026#39;envs\u0026#39;,\rstages: [\r{ id: \u0026#34;dev\u0026#34;, stackBuilder: blueprint.clone(\u0026#39;ap-southeast-1\u0026#39;).addOns(devBootstrapArgo)} // HERE WE ADD OUR NEW ADDON WITH THE CONFIGURED ARGO CONFIGURATIONS\r]\r}) .build(scope, id+\u0026#39;-stack\u0026#39;, props);\r}\r} Thực hiện push thay đổi lên Github repository git add . git commit -m \u0026#34;Bootstrapping ArgoCD\u0026#34;\rgit push https://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@github.com/AWS-First-Cloud-Journey/my-eks-blueprints.git Đợi 15 phút sau sẽ hoàn thành Thực hiện kiểm tra argocd namespace bằng lệnh. kubectl get ns "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Các bước chuẩn bị Để tiến hành bài lab, chúng ta phải chuẩn bị môi trường Cloud9 và tạo IAM role cho Cloud9 instance.\nĐồng thời cài đặt Kubernetes Tool\nNội dung Tạo môi trường Cloud9 Cài đặt công cụ Tạo IAM role Gán IAM role cho Cloud9 instance Cập nhật IAM role "
},
{
	"uri": "//localhost:1313/vi/6-onboardteams/6.2-onboardingteams/",
	"title": "Cấu hình các nhóm",
	"tags": [],
	"description": "",
	"content": "Cấu hình các nhóm Trong phần trước, chúng ta tạo cả hai Applicationv à Platform team template.\nThêm code sau vào template // lib/pipeline.ts // lib/pipeline.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport { Construct } from \u0026#39;constructs\u0026#39;;\rimport * as blueprints from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rimport { KubernetesVersion } from \u0026#39;aws-cdk-lib/aws-eks\u0026#39;;\rimport { TeamPlatform, TeamApplication } from \u0026#39;../teams\u0026#39;; // HERE WE IMPORT TEAMS\rexport default class PipelineConstruct extends Construct {\rconstructor(scope: Construct, id: string, props?: cdk.StackProps) {\rsuper(scope, id)\rconst account = props?.env?.account!;\rconst region = props?.env?.region!;\rconst blueprint = blueprints.EksBlueprint.builder()\r.account(account)\r.region(region)\r.clusterProvider(\rnew blueprints.GenericClusterProvider({\rversion: \u0026#39;auto\u0026#39;,\r})\r)\r.addOns()\r.teams(new TeamPlatform(account), new TeamApplication(\u0026#39;burnham\u0026#39;,account)); // HERE WE USE TEAMS\rblueprints.CodePipelineStack.builder()\r.name(\u0026#34;eks-blueprints-workshop-pipeline\u0026#34;)\r.owner(\u0026#34;FromSunNews\u0026#34;)\r.repository({\rrepoUrl: \u0026#39;my-eks-blueprints\u0026#39;,\rcredentialsSecretName: \u0026#39;eks-workshop-token\u0026#39;,\rtargetRevision: \u0026#39;main\u0026#39;\r})\r.wave({\rid: \u0026#34;envs\u0026#34;,\rstages: [\r{ id: \u0026#34;dev\u0026#34;, stackBuilder: blueprint.clone(\u0026#39;ap-southeast-1\u0026#39;) }\r]\r})\r.build(scope, id + \u0026#39;-stack\u0026#39;, props);\r}\r} Thực hiện push thay đổi lên remote repository Github cd ..\rgit add . git commit -m \u0026#34;adding teams\u0026#34;\rgit push https://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@github.com/AWS-First-Cloud-Journey/my-eks-blueprints.git Đợi khoảng thời gian khoảng 15 phút sẽ Succeeded Triển khai thành công Thực hiện kiểm tra\nkubectl get ns Bạn sẽ nhận thấy rằng team-burnham có trong namespace "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.2-connectec2/",
	"title": "Kết nối SSH từ Visual Studio Code đến EC2 Instance",
	"tags": [],
	"description": "",
	"content": "Kết nối SSH từ Visual Studio Code đến EC2 Instance Kết nối SSH từ Visual Studio Code đến EC2 Instance là giải pháp nhanh chóng thay thế cho việc sử dụng Cloud9.\nChúng ta sẽ tải Visual Studio Code và extensions có tên là Remote - SSH\nBạn có thể tải vs code tại đây: Download VSCode\nSau khi tải xong. Chúng ta sẽ tải extension sau đây:\nSau khi tải xong chúng ta nhấn có biểu tượng ở phía dưới góc trái màn hình một hộp thoại sẽ được mở ra. Chúng ta sẽ nhấn vào Connect to Host. Nhấn vào Add New SSH Host. Trong ô input nhập eks-blueprint-remote và nhấn Enter. Nhấn vào đường dẫn trong C:\\Users\\ADMIN.ssh\\config để cấu hình Ngay tại khối code SSH name mới được cấu hình trước đó hãy thay đổi thông tin đúng với địa chỉ IPv4 của EC2 Instance và đường dẫn đến Key Pair trong máy của bạn.\nBấm vào biểu tượng SSH ở dưới cùng góc bên trái và bắt đầu thực hiện Connect. Chọn Continue Nhấn vào Linux Chọn Open Folder và Click OK Đây là giao diện sau khi kết nối "
},
{
	"uri": "//localhost:1313/vi/7-add-ons/7.2-testingcluster/",
	"title": "Kiểm tra Cluster Autoscaler",
	"tags": [],
	"description": "",
	"content": "Kiểm tra Cluster Autoscaler chúng ta đã có thể triển khai Cluster Autoscaler thành công.\nCác bước sau sẽ giúp kiểm tra và xác thực chức năng Cluster Autoscaler trong cluster của bạn.\nTriển khai một ứng dụng mẫu dưới dạng triển khai. Mở rộng quy mô triển khai lên 50. Giám sát sự kiện mở rộng quy mô.\nTriển khai ứng dụng mẫu\nKiểm tra số lượng node có sẵn. kubectl get nodes Thực hiện tạo sample nginx application cat \u0026lt;\u0026lt;EoF\u0026gt; ~/environment/nginx.yaml\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: nginx-to-scaleout\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: nginx\rtemplate:\rmetadata:\rlabels:\rservice: nginx\rapp: nginx\rspec:\rcontainers:\r- image: nginx\rname: nginx-to-scaleout\rresources:\rlimits:\rcpu: 500m\rmemory: 512Mi\rrequests:\rcpu: 500m\rmemory: 512Mi\rEoF\rkubectl apply -f ~/environment/nginx.yaml Kiểm tra pod đang chạy kubectl get pod -l app=nginx Thực hiện Scale deployment replicas Bây giờ chúng ta có thể mở rộng quy mô triển khai lên 10 bản sao và quan sát việc triển khai: kubectl scale --replicas=10 deployment/nginx-to-scaleout Tiếp đến ta thực hiện Monitoring the scaling event Một số pod sẽ ở trạng thái Pending, điều này sẽ kích hoạt trình tự động cluster-autoscaler để mở rộng nhóm EC2: kubectl get pods -l app=nginx -o wide --watch Để xem cluster-autoscaler log kubectl -n kube-system logs -f deployment/blueprints-addon-cluster-autoscaler-aws-cluster-autoscaler Bạn có thể liệt kê tất cả các node kubectl get nodes Để xóa tài nguyên thực hiện kubectl delete deploy nginx-to-scaleout\rrm ~/environment/nginx.yaml "
},
{
	"uri": "//localhost:1313/vi/5-deploymentpipeline/5.2-accesscluster/",
	"title": "Tạo Pipeline",
	"tags": [],
	"description": "",
	"content": "Tạo Pipeline Thiết lập AWS Secrets Manager Chúng ta sẽ cần thêm GitHub Personal Access Token vào AWS Secrets Manager của AWS để tận dụng AWS CodePipeline và GitHub vì pipeline của chúng ta sẽ tận dụng webhook để chạy thành công.\nBạn có thể tham khảo thêm về cách tạo GitHub Personal Access Token\nSau khi tạo GitHub Personal Access Token\nChúng ta quay lại VSCode Terminal Thực hiện tạo Secret trong Secrets Manager với tên eks-workshop-token aws secretsmanager create-secret --name \u0026#34;eks-workshop-token\u0026#34; --description \u0026#34;github access token\u0026#34; --secret-string \u0026#34;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\u0026#34; Lưu ý: nhớ thay secret-string của bạn bằng token bạn đã tạo.\nChúng ta có thể tạo một tài nguyên CodePipelineStack mới bằng cách tạo một CDK Construct mới trong thư mục lib/, sau đó nhập Construct vào main entrypoint file.\nThực hiện tạo construct file mới. touch lib/pipeline.ts Sau khi tệp được tạo, hãy mở tệp và thêm đoạn mã sau để tạo pipeline construct // lib/pipeline.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport { Construct } from \u0026#39;constructs\u0026#39;;\rimport * as blueprints from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rimport { KubernetesVersion } from \u0026#39;aws-cdk-lib/aws-eks\u0026#39;;\rexport default class PipelineConstruct extends Construct {\rconstructor(scope: Construct, id: string, props?: cdk.StackProps) {\rsuper(scope, id)\rconst account = props?.env?.account!;\rconst region = props?.env?.region!;\rconst blueprint = blueprints.EksBlueprint.builder()\r.account(account)\r.region(region)\r.clusterProvider(\rnew blueprints.GenericClusterProvider({\rversion: \u0026#39;auto\u0026#39;\r})\r)\r.addOns()\r.teams();\rblueprints.CodePipelineStack.builder()\r.name(\u0026#34;eks-blueprints-workshop-pipeline\u0026#34;)\r.owner(\u0026#34;your-github-username\u0026#34;)\r.repository({\rrepoUrl: \u0026#39;your-repo-name\u0026#39;,\rcredentialsSecretName: \u0026#39;github-token\u0026#39;,\rtargetRevision: \u0026#39;main\u0026#39;\r})\r.build(scope, id+\u0026#39;-stack\u0026#39;, props);\r}\r} Thực hiện cấu hình:\nname, chúng ta nhập eks-blueprints-workshop-pipeline hoặc tên pipeline mà bạn muốn. owner, nhập tên github của bạn. (trong bài lab, nhập AWS-First-Cloud-Journey) repoUrl, nhập tên của repo. (Trong bài lab, nhập my-eks-blueprints) credentialsSecretName, nhập secret của bạn (Trong bài lab, nhập eks-workshop-token) targetRevision, nhập revision main Để đảm bảo chúng ta có thể truy cập vào Construct, chúng ta cần import và khởi tạo một construct mới.\nThay đổi nội dung của file bin/my-eks-blueprints.ts // bin/my-eks-blueprints.ts\r// bin/my-eks-blueprints.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport ClusterConstruct from \u0026#39;../lib/my-eks-blueprints-stack\u0026#39;;\rimport * as dotenv from \u0026#39;dotenv\u0026#39;;\rimport PipelineConstruct from \u0026#39;../lib/pipeline\u0026#39;; // IMPORT OUR PIPELINE CONSTRUCT\rdotenv.config();\rconst app = new cdk.App();\rconst account = process.env.CDK_DEFAULT_ACCOUNT!;\rconst region = process.env.CDK_DEFAULT_REGION;\rconst env = { account, region }\rnew ClusterConstruct(app, \u0026#39;cluster\u0026#39;, { env });\rnew PipelineConstruct(app, \u0026#39;pipeline\u0026#39;, { env }); Thực hiện kiểm tra danh sách pipeline cdk list Thực hiện thêm Stage. Trong bước này, chúng ta thực hiện thêm các stage cho pipeline( trong bài lab sử dụng stage dev, bạn có thể triển khai thêm các stage dành cho test và production ở các region khác) // lib/pipeline.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport { Construct } from \u0026#39;constructs\u0026#39;;\rimport * as blueprints from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rimport { KubernetesVersion } from \u0026#39;aws-cdk-lib/aws-eks\u0026#39;;\rexport default class PipelineConstruct extends Construct {\rconstructor(scope: Construct, id: string, props?: cdk.StackProps) {\rsuper(scope, id)\rconst account = props?.env?.account!;\rconst region = props?.env?.region!;\rconst blueprint = blueprints.EksBlueprint.builder()\r.account(account)\r.region(region)\r.clusterProvider(\rnew blueprints.GenericClusterProvider({\rversion: \u0026#39;auto\u0026#39;\r})\r)\r.addOns()\r.teams();\rblueprints.CodePipelineStack.builder()\r.name(\u0026#34;eks-blueprints-workshop-pipeline\u0026#34;)\r.owner(\u0026#34;your-github-username\u0026#34;)\r.repository({\rrepoUrl: \u0026#39;your-repo-name\u0026#39;,\rcredentialsSecretName: \u0026#39;github-token\u0026#39;,\rtargetRevision: \u0026#39;main\u0026#39;\r})\r// WE ADD THE STAGES IN WAVE FROM THE PREVIOUS CODE\r.wave({\rid: \u0026#34;envs\u0026#34;,\rstages: [\r{ id: \u0026#34;dev\u0026#34;, stackBuilder: blueprint.clone(\u0026#39;ap-southeast-1\u0026#39;) }\r]\r})\r.build(scope, id + \u0026#39;-stack\u0026#39;, props);\r}\r} Sử dụng class blueprints.StackStage hỗ trợ tạo để định nghĩa các stage của chúng ta bằng cách sử dụng .stage\nSử dụng .wave hỗ trợ để triển khai song song.\nTrong bài lab, chúng ta đang triển khai 1 cluster.\nNếu trường hợp bạn triển khai nhiều cluster, để giảm thiểu, chúng ta sẽ chỉ cần thêm .wave vào danh sách các stage để bao gồm cách bạn muốn cấu trúc các stage triển khai khác nhau của mình trong pipeline. (tức là khác nhau add-ons, region deployment v.v.).\nStack của chúng ta sẽ triển khai các cluster sau: EKS trong môi trường dev. CodePipeline triển khai tới region: ap-southeast-1.\nThực hiện kiểm tra lại danh sách pipeline cdk list Kết quả như sau:\ncluster-stack\rpipeline-stack\rpipeline-stack/dev/dev-blueprint "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.3-installtool/",
	"title": "Cài đặt Tool",
	"tags": [],
	"description": "",
	"content": "Cài đặt kubectl Các cluster của Amazon EKS sẽ cần công cụ kubectl và kubelet và aws-cli hoặc aws-iam-authenticator để cho phép chứng thực IAM cho Kubernetes cluster của bạn.\nChúng ta sử dụng lệnh sau để cài kubectl. sudo curl --silent --location -o /usr/local/bin/kubectl \\\rhttps://amazon-eks.s3.us-west-2.amazonaws.com/1.21.2/2021-07-05/bin/linux/amd64/kubectl\rsudo chmod +x /usr/local/bin/kubectl Các bạn có thể xem thêm cài đặt kubectl trên AWS\nCập nhật awscli curl \u0026#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026#34; -o \u0026#34;awscliv2.zip\u0026#34;\runzip awscliv2.zip\rsudo ./aws/install Chúng ta thực hiện xác thực. for command in kubectl jq envsubst aws\rdo\rwhich $command \u0026amp;\u0026gt;/dev/null \u0026amp;\u0026amp; echo \u0026#34;$command in path\u0026#34; || echo \u0026#34;$command NOT FOUND\u0026#34;\rdone Kích hoạt kubectl bash_completion kubectl completion bash \u0026gt;\u0026gt; ~/.bash_completion\r. /etc/profile.d/bash_completion.sh\r. ~/.bash_completion "
},
{
	"uri": "//localhost:1313/vi/5-deploymentpipeline/5.3-pipelineinaction/",
	"title": "Pipeline in Action",
	"tags": [],
	"description": "",
	"content": "Pipeline in Action Các construct đã được sửa đổi, sau đó lưu lại.\nChúng ta thực hiện add, commit và push các thay đổi của bạn vào remote repository git add .\rgit commit -m \u0026#34;Setting up EKS Blueprints deployment pipeline\u0026#34;\rgit branch -M main\rgit config credential.helper store\rgit push https://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@github.com/AWS-First-Cloud-Journey/my-eks-blueprints.git Vì đây là lần đầu tiên bạn push lên reomte repository của Github, Cloud 9 sẽ nhắc bạn nhập thông tin đăng nhập GitHub của bạn. Bạn sẽ cần sử dụng mật khẩu GitHub của mình (nếu 2FA chưa được bật) hoặc Github Token của bạn (nếu 2FA được bật). Trong bài lab, chúng ta sử dụng Github Token vì sử dụng user name và password đã không còn hiệu lực.\nNếu quên Secret bạn có thể xem trong AWS Secret Manager\nLệnh gọi credential.helper dùng để lưu trữ thông tin đăng nhập của bạn để bạn không cần phải tiếp tục nhập chúng mỗi khi thực hiện thay đổi.\nLưu ý: git push sử dùng kèm token theo https://[token]@github.com/[github_name]/[repo_name].git\nKiểm tra lại repository xem đã được push lên chưa? Sau khi push lên repository, chúng ta thực hiện deploy pipeline stack. cdk deploy pipeline-stack Bạn sẽ được nhắc xác nhận việc triển khai pipeline stack.\nNhập y và sau đó nhấn enter. Sau khi triển khai thành công sẽ hiển thị Stack ARN Quay lại giao diện AWS Management Console Tìm và chọn CodePipeline Bạn sẽ quan sát thấy quá trình triển khai đang diễn ra. Đợi khoảng 30 phút sau, Pipeline hiển thị Succeeced\nCodePipeline sẽ nhận các thay đổi được thực hiện trong remote repository và pipelne sẽ bắt đầu xây dựng. Bản cập nhật(thêm, xóa, sửa code) có thể được nhìn thấy trong CodePipeline Console để xác minh rằng các stage được xây dựng chính xác.\nChọn vào tên pipeline.\nXem các bước Source và Build\nSource: Source stage chạy một action để truy xuất các thay đổi code khi pipeline được chạy theo cách thủ công hoặc khi một event webhook được gửi từ source provider. Trong trường hợp của chúng ta, mỗi khi chúng ta thực hiện thay đổi code trong my-eks-blueprints repository của mình và reflect những thay đổi trong remote repo, event sẽ được gửi đến pipeline(kèm GitHub personal access token) để kích hoạt thực thi pipline mới. Build : build stage cho phép bạn chạy các action test và build như một phần của pipeline. Trong quá trình Build, pipeline sẽ chạy các script để đảm bảo mọi thứ hoạt động như dự định. Điều này bao gồm npm package installations, version checking và CDK synth. Bất kỳ lỗi nào trong cấu hình từ repo của bạn đều có thể không thực hiện được stage này. Bạn có thể xem danh sách các lệnh được chạy trong hành động này bằng cách nhấp vào Details trong actions (bên dưới tên của nó và AWS Codebuild). Tiếp theo là UpdatePipeline và Assets\nUpdatePipeline : Đây là một extra build stage chạy để kiểm tra pipeline có cần cập nhật hay không. Ví dụ: nếu code được thay đổi để bao gồm các stage bổ sung (ngoài production), UpdatePipeline sẽ chạy build và reconfigure pipeline cần thêm các stage bổ sung đó. Stage này là Assets cần thiết để chạy các stage. Assets : Đây là một loạt các build action xử lý các asset cần thiết để triển khai EKS cluster. Asset, trong ngữ cảnh của CDK, là các tệp cục bộ, thư mục hoặc Docker image có thể được đóng gói vào các thư viện và ứng dụng CDK. Những nội dung hoặc hiện vật này cần thiết để ứng dụng CDK của chúng ta hoạt động. Các asset này cho phép Framework hoạt động bình thường, vì chúng chứa các tham số và cấu hình được sử dụng để triển khai các tài nguyên cần thiết, tức là Cluster Provider, Kubernetes resources trong Cluster, IAM, add-ons với Helm Charts, v.v. Asset được lưu trữ trên AWS dưới dạng các Lambda Function cho các thực thi và tệp được lưu trữ S3 Artifacts bucket. Cuối cùng là dev (Prepare và Deploy) Envs (our wave): wave là một tùy chọn triển khai cho các pipeline cung cấp nhiều stage (hoặc môi trường) song song. Vì CDK tổng hợp code thành một CloudFormation template, bạn có thể xem trong bảng điều khiển quản lý việc triển khai các stack dưới dạng mẫu CloudFormation. Khi mà bạn bị lỗi trong quá trình chạy pipeline thì hãy nhấp vào xem chi tiết Lỗi này là số lượng hàng đợi bị giới hạn. Bạn hãy thực hiện chạy lại Và cuối cùng nó đã chạy được "
},
{
	"uri": "//localhost:1313/vi/8-deploy/8.3-manage/",
	"title": "Quản lý trên ArgoCD",
	"tags": [],
	"description": "",
	"content": "Quản lý workload trên ArgoCD Bây giờ, chúng ta đăng nhập vào giao diện người dùng và xem cách workloads đang được quản lý thông qua ArgoCD.\nTheo mặc định, dịch vụ argocd-server không được công khai. Với mục đích của hội thảo này, chúng ta sẽ sử dụng Load Balancer để sử dụng. kubectl patch svc blueprints-addon-argocd-server -n argocd -p \u0026#39;{\u0026#34;spec\u0026#34;: {\u0026#34;type\u0026#34;: \u0026#34;LoadBalancer\u0026#34;}}\u0026#39; Đợi 5 phút sau, LoadBalancer được tạo. export ARGOCD_SERVER=`kubectl get svc blueprints-addon-argocd-server -n argocd -o json | jq --raw-output \u0026#39;.status.loadBalancer.ingress[0].hostname\u0026#39;` TYPE và EXTERNAL-IP trên argo server service đã thay đổi thành LoadBalancer. Copy EXTERNAL-IP của LoadBalancer. kubectl get svc -n argocd Mở trình duyệt và dán EXTERNAL-IP của LoadBalancer vào. Thực hiện tạo mật khẩu tự động và username là admin kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\u0026#34;{.data.password}\u0026#34; | base64 -d Sau khi đăng nhập, quan sát các workload trên ArgoCD UI "
},
{
	"uri": "//localhost:1313/vi/6-onboardteams/6.3-clusteraccessforteams/",
	"title": "Quyền truy cập nhóm",
	"tags": [],
	"description": "",
	"content": "Quyền truy cập nhóm Burnham Team, chỉ có quyền truy cập vào các tài nguyên trong namespace dành riêng của họ cùng với việc chứng minh cách chúng ta có thể sử dụng Kubernative native construct để đảm bảo rằng chỉ những người dùng trong team-burnham namespace có thể truy cập các tài nguyên đó. Đây còn được gọi là soft multi-tenancy bạn đang sử dụng các Kubernetes constructs như namespaces, quotas, và network policies để ngăn các ứng dụng được triển khai trong các namespace khác nhau giao tiếp với nhau. kubectl describe role -n team-burnham Bạn có thể thấy rằng Team Burnham chỉ có thể get và list một tập hợp các tài nguyên Kubernetes tập trung vào ứng dụng (pods, daemonsets, deployments, replicasets, statefulsets, và jobs). Bạn sẽ nhận thấy rằng họ không có quyền create hoặc delete tài nguyên trong namespace tương ứng của họ.\nTruy xuất role đã tạo cho Team burnham bằng cách chạy lệnh sau: aws cloudformation describe-stacks --stack-name dev-dev-blueprint | jq -r \u0026#39;.Stacks[0].Outputs[] | select(.OutputKey|match(\u0026#34;burnhamteamrole\u0026#34;))| .OutputValue\u0026#39; Tạo thông tin đăng nhập cho application aws iam create-login-profile --user-name application --password Ekscdkworkshop123! Truy cập vào AWS\nThực hiện đăng nhập với IAM user Nhập Account ID của bạn Chọn Next Tiếp theo,\nNhập IAM user name là application Nhập password vừa tạo Chọn Sign in Hoàn thành đăng nhập Trong giao diện AWS\nChọn Switch role Trong giao diện Switch Role\nAccount, nhập Account ID của bạn Sau đó, nhập Role Chọn Switch Role Hoàn thành Switch Role Truy cập vào EKS Tại đây, bạn sẽ thấy thông báo lỗi cho biết rằng người dùng Team Burnham KHÔNG được phép liệt kê các triển khai trong tất cả các namespace. Khi bạn chọn team-burnham trong namespace, bạn sẽ thấy thông báo bị cấm biến mất. Điều này có nghĩa là bạn hiện đang hiển thị workload của Team Burnham (không có workload nào vì chưa triển khai bất kỳ workload nào). "
},
{
	"uri": "//localhost:1313/vi/7-add-ons/7.3-createaddons/",
	"title": "Tạo add-ons",
	"tags": [],
	"description": "",
	"content": "Tạo add-ons Đầu tiên, chúng ta tạo kubevious_addon.ts trong thư mục lib touch lib/kubevious_addon.ts Thêm đoạn code sau vào file kubevious_addon.ts // lib/kubevious_addon.ts\rimport { Construct } from \u0026#39;constructs\u0026#39;;\rimport * as blueprints from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rimport { setPath } from \u0026#39;@aws-quickstart/eks-blueprints/dist/utils/object-utils\u0026#39;;\r/**\r* User provided options for the Helm Chart\r*/\rexport interface KubeviousAddOnProps extends blueprints.HelmAddOnUserProps {\rversion?: string,\ringressEnabled?: boolean,\rkubeviousServiceType?: string,\r}\r/**\r* Default props to be used when creating the Helm chart\r*/\rconst defaultProps: blueprints.HelmAddOnProps \u0026amp; KubeviousAddOnProps = {\rname: \u0026#34;blueprints-kubevious-addon\u0026#34;,\rnamespace: \u0026#34;kubevious\u0026#34;,\rchart: \u0026#34;kubevious\u0026#34;,\rversion: \u0026#34;0.9.13\u0026#34;,\rrelease: \u0026#34;kubevious\u0026#34;,\rrepository: \u0026#34;https://helm.kubevious.io\u0026#34;,\rvalues: {},\ringressEnabled: false,\rkubeviousServiceType: \u0026#34;ClusterIP\u0026#34;,\r};\r/**\r* Main class to instantiate the Helm chart\r*/\rexport class KubeviousAddOn extends blueprints.HelmAddOn {\rreadonly options: KubeviousAddOnProps;\rconstructor(props?: KubeviousAddOnProps) {\rsuper({...defaultProps, ...props});\rthis.options = this.props as KubeviousAddOnProps;\r}\rdeploy(clusterInfo: blueprints.ClusterInfo): Promise\u0026lt;Construct\u0026gt; {\rlet values: blueprints.Values = populateValues(this.options);\rconst chart = this.addHelmChart(clusterInfo, values);\rreturn Promise.resolve(chart);\r}\r}\r/**\r* populateValues populates the appropriate values used to customize the Helm chart\r* @param helmOptions User provided values to customize the chart\r*/\rfunction populateValues(helmOptions: KubeviousAddOnProps): blueprints.Values {\rconst values = helmOptions.values ?? {};\rsetPath(values, \u0026#34;ingress.enabled\u0026#34;, helmOptions.ingressEnabled);\rsetPath(values, \u0026#34;kubevious.service.type\u0026#34;, helmOptions.kubeviousServiceType);\rsetPath(values, \u0026#34;mysql.generate_passwords\u0026#34;, true);\rreturn values;\r} Sau đó thêm đoạn code sau vào lib/pipeline.ts // lib/pipeline-stack.ts\rimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;;\rimport { Construct } from \u0026#39;constructs\u0026#39;;\rimport * as blueprints from \u0026#39;@aws-quickstart/eks-blueprints\u0026#39;;\rimport { TeamPlatform, TeamApplication } from \u0026#39;../teams\u0026#39;; export default class PipelineConstruct extends Construct {\rconstructor(scope: Construct, id: string, props?: cdk.StackProps){\rsuper(scope,id)\rconst blueprint = blueprints.EksBlueprint.builder()\r.account(account)\r.region(region)\r.addOns(\rnew blueprints.ClusterAutoScalerAddOn,\rnew blueprints.KubeviousAddOn(), // New addon goes here\r) .teams(new TeamPlatform(account), new TeamApplication(\u0026#39;burnham\u0026#39;,account));\rblueprints.CodePipelineStack.builder()\r.name(\u0026#34;eks-blueprints-workshop-pipeline\u0026#34;)\r.owner(\u0026#34;your-github-username\u0026#34;)\r.repository({\rrepoUrl: \u0026#39;your-repo-name\u0026#39;,\rcredentialsSecretName: \u0026#39;github-token\u0026#39;,\rtargetRevision: \u0026#39;main\u0026#39;\r})\r.wave({\rid: \u0026#34;envs\u0026#34;,\rstages: [\r{ id: \u0026#34;dev\u0026#34;, stackBuilder: blueprint.clone(\u0026#39;ap-southeast-1\u0026#39;)}\r]\r})\r.build(scope, id+\u0026#39;-stack\u0026#39;, props);\r}\r} Thực hiện push lên Github repository git add .\rgit commit -m \u0026#34;adding Kubevious\u0026#34;\rgit push https://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@github.com/AWS-First-Cloud-Journey/my-eks-blueprints.git Đợi 15 phút sau sẽ hoàn thành Khi pipeline hoàn tất, chúng ta có thể thấy add-ons của mình đang hoạt động bằng cách chạy lệnh bên dưới: kubectl port-forward $(kubectl get pods -n kubevious -l \u0026#34;app.kubernetes.io/component=kubevious-ui\u0026#34; -o jsonpath=\u0026#34;{.items[0].metadata.name}\u0026#34;) 8080:80 -n kubevious Trong giao diện Cloud9 Chọn Preview Chọn Preview Running Application Giao diện xuất hiện Chọn vào biểu tượng gốc phải để mở rộng Giao diện mở rộng Tiến hành khám phá Chỉ sử dụng giao diện trên trình duyệt Desktop Giao diện chi tiết của kubevious "
},
{
	"uri": "//localhost:1313/vi/3-createeksblueprints/",
	"title": "Tạo EKS Blueprints",
	"tags": [],
	"description": "",
	"content": "Tạo EKS Blueprints Tham khảo cách tạo Repository Github\nTruy cập vào New repository của Github\nTrong giao diện Create a new repository, nhập my-eks-blueprints đối với Repository name Chọn Public Chọn Create repisitory Sau khi tạo repository thành công\nSao chép và lưu trữ đường dẫn HTTPS của Git repository Trong giao diện Github chúng ta sẽ cài đặt và tạo token\nChọn vào Avatar của tài khoản Github của bạn Chọn Settings Sau đó, kéo xuống và chọn Developer settings\nTrong giao diện Developer settings\nChọn Personal access tokens Chọn Generate new toke Trong giao diện Generate new token\nNote, nhập eks-workshop-token Chọn các scope sau: repo và admin:repo_hook Chọn Generate token Chọn Generate token Hoàn thành Generate token\nSao chép và lưu giữ token Tham khảo cách tạo Personal Access Token\nTải git sudo dnf install git -y\rgit --version Thực hiện clone repository git clone https://github.com/\u0026lt;your-alias\u0026gt;/my-eks-blueprints.git "
},
{
	"uri": "//localhost:1313/vi/4-createcdkproject/",
	"title": "Tạo CDK project",
	"tags": [],
	"description": "",
	"content": "Tạo CDK project Đầu tiên chúng ta Thay đổi đường dẫn đến main repo và tải nvm cd my-eks-blueprints\rcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\rexport NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34;\r[ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34;\rsource ~/.bashrc\rnvm -v Sử dụng phiên bản node 18 nvm install v18\rnvm use v18\rnode -v\rnpm -v Bạn cần sử dụng phien bản node trên 14.15.0 để sử dụng được cdk. Xem thêm tại đây Tải Typescript và tải CDK phiên bản 2.147.3 npm -g install typescript\rnpm install -g aws-cdk@2.147.3\rcdk --version thực hiện tạo CDK project mới sử dụng typescript cdk init app --language typescript Trong giao diện VSCode Xem sidebar Xem cấu trúc của project lib / : Đây là nơi các stack hoặc construct CDK project của bạn được định nghĩa. bin / my-eks-blueprints.ts : Đây là entrypoint của CDK project. Nó sẽ tải các contructs được định nghĩa trong lib / . Bạn có thể xem thêm tài liệu về CDK\nXác thực AWS_DEFAULT_REGION và ACCOUNT_ID export AWS_DEFAULT_REGION=ap-southeast-1\rexport ACCOUNT_ID=212454837823 Lưu ý: nhớ thay đổi ACCOUNT_ID của bạn để thực hiện bài lab.\nChúng ta thực hiện khởi tạo Boostrap account Để bootstrapping chúng ta thực hiện lệnh. cdk bootstrap --trust=$ACCOUNT_ID \\\r--cloudformation-execution-policies arn:aws:iam::aws:policy/AdministratorAccess \\\raws://$ACCOUNT_ID/$AWS_REGION Khi thực hiện bootstrap thành công sẽ xuất hiện như sau: Environment aws://212454837823/ap-southeast-1 bootstrapped. Chúng ta tiếp tục chạy lệnh cài đặt module eks-blueprints và dotenv cho project npm i @aws-quickstart/eks-blueprints dotenv "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.4-createrole/",
	"title": "Tạo IAM role",
	"tags": [],
	"description": "",
	"content": "Tạo IAM role cho Cloud9 instance Đầu tiên, chúng ta đến giao diện AWS Management Console\nTìm và chọn IAM Trong giao diện IAM\nChọn Role Chọn Create role Trong bước Select trusted entity\nChọn AWS service Chọn EC2 Chọn Next Trong bước Add permission\nTìm AdministratorAccess Chọn AdministratorAccess Chọn Next Hoàn thành Name\nName, nhập eks-blueprints-cdk-workshop-admin Chọn Create role Hoàn thành tạo IAM role cho EC2 Instance "
},
{
	"uri": "//localhost:1313/vi/5-deploymentpipeline/5.4-accessingthecluster/",
	"title": "Truy cập Cluster",
	"tags": [],
	"description": "",
	"content": "Truy cập Cluster Truy cập Cluster Cài đặt quyền truy cập vào cluster export KUBE_CONFIG=$(aws cloudformation describe-stacks --stack-name dev-dev-blueprint | jq -r \u0026#39;.Stacks[0].Outputs[] | select(.OutputKey|match(\u0026#34;ConfigCommand\u0026#34;))| .OutputValue\u0026#39;)\r$KUBE_CONFIG Khi kubeconfig đã được cập nhật, bạn sẽ có thể truy cập vào EKS cluster kubectl get svc "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.5-attachrole/",
	"title": "Gán IAM role",
	"tags": [],
	"description": "",
	"content": "Gán IAM role cho Cloud9 instance Đầu tiên, chúng ta đến giao diện AWS Management Console Tìm ec2 và chọn Instance Trong giao diện EC2 instance\nChọn EKS Blueprint Instance Chọn Actions Chọn Security Chọn Modify IAM role Trong giao diện Modify IAM role\nChọn eks-blueprints-cdk-workshop-admin role Chọn Update IAM role "
},
{
	"uri": "//localhost:1313/vi/5-deploymentpipeline/",
	"title": "Tạo Deployment Pipeline",
	"tags": [],
	"description": "",
	"content": "Tạo Deployment Pipeline Trong phần này, chúng ta sẽ xem xét cách thiết lập một deployment pipeline để tự động hóa các bản cập nhật cho cluster của chúng ta. Mặc dù thuận tiện khi tận dụng công cụ dòng lệnh CDK để triển khai stack đầu tiên của bạn, nhung chúng ta nên thiết lập các pipeline tự động chịu trách nhiệm triển khai và cập nhật cơ sở hạ tầng EKS của bạn. Chúng ta sẽ sử dụng CodePipelineStack của Framework để triển khai môi trường ở các khu vực khác nhau.\nCodePipelineStack là một cấu trúc để phân phối liên tục các ứng dụng AWS CDK một cách dễ dàng. Bất cứ khi nào bạn kiểm tra mã nguồn của ứng dụng AWS CDK vào GitHub, stack có thể tự động xây dựng, kiểm tra và triển khai phiên bản mới của bạn.\nCodePipelineStack tự cập nhật: nếu bạn thêm các stage hoặc stack ứng dụng, pipeline sẽ tự động cấu hình lại chính nó để triển khai các stage hoặc stack mới đó.\nNội dung Tạo Cluster Tạo Pipeline Pipeline in Action Truy cập Cluster "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.6-updaterole/",
	"title": "Cập nhật IAM",
	"tags": [],
	"description": "",
	"content": "Cập nhật IAM role Tiến hành cấu hình export ACCOUNT_ID=xxx\rexport AWS_REGION=xxx Kiểm tra AWS_REGION test -n \u0026#34;$AWS_REGION\u0026#34; \u0026amp;\u0026amp; echo AWS_REGION is \u0026#34;$AWS_REGION\u0026#34; || echo AWS_REGION is not set Lưu lại vào bash_profile echo \u0026#34;export ACCOUNT_ID=${ACCOUNT_ID}\u0026#34; | tee -a ~/.bash_profile\recho \u0026#34;export AWS_REGION=${AWS_REGION}\u0026#34; | tee -a ~/.bash_profile\raws configure set default.region ${AWS_REGION}\raws configure get default.region Xác thực IAM role aws sts get-caller-identity --query Arn | grep eks-blueprints-cdk-workshop-admin -q \u0026amp;\u0026amp; echo \u0026#34;IAM role valid\u0026#34; || echo \u0026#34;IAM role NOT valid\u0026#34; Nếu kết quả là IAM role NOT valid, hãy kiểm tra lại các bước trước xem thông tin IAM role bạn tạo và gán vào Cloud9 Workspace có chính xác không nhé.\n"
},
{
	"uri": "//localhost:1313/vi/6-onboardteams/",
	"title": "Quản lý nhóm bằng IaC",
	"tags": [],
	"description": "",
	"content": "OnboardTeams Trong phần này, chúng ta sẽ giới thiệu các nhóm của mình đến EKS Blueprints. chúng ta sẽ xem xét cách tham gia Platform team và Application team cũng như đảm bảo rằng chúng ta đang xác định các cấp quyền truy cập phù hợp cho các nhóm của mình. Một ví dụ là Application team của chúng ta phải có quyền truy cập chỉ đọc vào cơ sở hạ tầng cơ bản và phải được mở rộng phạm vi đến namespace của họ trong khi Platform team của chúng ta sẽ có các cấp độ truy cập chi tiết hơn vì Platform team sẽ chịu trách nhiệm quản lý cơ sở hạ tầng bên dưới.\nLợi ích của việc quản lý nhóm bằng cách sử dụng cơ sở hạ tầng dưới dạng mã (IaC):\nMã tự lập tài liệu Logic tập trung liên quan đến nhóm Khả năng sử dụng các template có thể lặp lại để tạo môi trường mới. Nội dung OnboardTeams Onboarding Teams Truy cập Cluster "
},
{
	"uri": "//localhost:1313/vi/7-add-ons/",
	"title": "Tiện ích bổ sung",
	"tags": [],
	"description": "",
	"content": "Tiện ích bổ sung Add-ons là các giải pháp của bên thứ ba (và native AWS) cung cấp các chức năng cần thiết để tối ưu hóa việc chạy EKS Blueprints hiệu quả. Add-ons cho phép bạn định cấu hình các công cụ và dịch vụ mà bạn muốn chạy để hỗ trợ EKS workload của bạn. Khi bạn định cấu hình các tiện ích bổ sung cho một blueprint, các tiện ích bổ sung sẽ được cung cấp tại thời điểm triển khai. Tiện ích bổ sung có thể triển khai cả tài nguyên cụ thể của Kubernetes và tài nguyên AWS cần thiết để hỗ trợ chức năng tiện ích bổ sung.\nLợi ích của việc tận dụng Add-on EKS Blueprints là bạn mở rộng khả năng tận dụng các dự án và công cụ nguồn mở do cộng đồng Kubernetes xây dựng. Các dự án và công cụ này giải quyết các lĩnh vực khác nhau của việc chạy workload của bạn trên Kubernetes như bảo mật, khả năng quan sát, CI / CD, GitOps, v.v.\nAdd-on Description AppMesh Adds an AppMesh controller and CRDs. ArgoCD Provisions Argo CD into your cluster. AWS Load Balancer Controlle Provisions the AWS Load Balancer Controller into your cluster Calico Adds the Calico 1.7.1 CNI/Network policy engine. Cluster Autoscaler Adds the standard cluster autoscaler. Container Insights Adds Container Insights support integrating monitoring with CloudWatch. CoreDNS Adds CoreDNS (flexible, extensible DNS server) Amazon EKS add-on. ExternalDNS Adds External DNS support for AWS to the cluster, integrating with Amazon Route 53 Kube Proxy Adds kube-proxy Amazon EKS add-on (maintains network rules on each Amazon EC2 node). Metrics Server Adds metrics server (pre-req for HPA and other monitoring tools). Nginx Adds NGINX ingress controller. Secrets Store Adds AWS Secrets Manager and Config Provider for Secret Store CSI Driver to the EKS Cluster. SSM Agent Adds Amazon SSM Agent to worker nodes. VPC CNI Adds the Amazon VPC CNI Amazon EKS addon to support native VPC networking. Weave GitOps Weave GitOps Core AddOn. X-Ray Adds XRay Daemon to the EKS Cluster. OPA Gatekeeper Adds policy management features to your cluster Velero Adds Velero to the EKS Cluster. Nội dung Giới thiệu add-ons Kiểm tra Cluster Autotscaler Tạo add-ons "
},
{
	"uri": "//localhost:1313/vi/8-deploy/",
	"title": "Triển khai Workload với ArgoCD",
	"tags": [],
	"description": "",
	"content": "Triển khai Workload với ArgoCD Giờ đây, bạn đã cấp phép thành công một EKS cluster với các team, role và pipeline của bạn để tự động hóa và quản lý cơ sở hạ tầng. Bước tiếp theo là tận dụng các phương pháp GitOps bằng cách sử dụng ArgoCD để quản lý và tự động hóa workload ứng dụng của chúng ta bằng cách sử dụng các công nghệ và công cụ mà bạn có thể đã quen thuộc như Git.\nTrong phần này, chúng ta sẽ trình bày cách tận dụng ArgoCD để triển khai và quản lý workload ứng dụng của chúng ta.\nArgoCD là gì? Cách thiết lập và triển khai workload của chúng ta với ArgoCD. Sử dụng giao diện người dùng ArgoCD để quản lý workload đã triển khai. Điều quan trọng là phải hiểu các nguyên tắc chính của GitOps trước khi đi sâu vào phần này. Các nguyên tắc chính của GitOps GitOps là khai báo có nghĩa là một hệ thống được quản lý bằng GitOps phải có trạng thái mong muốn của nó được thể hiện một cách khai báo. Trạng thái mong muốn được lưu trữ theo cách thực thi tính bất biến, lập phiên bản và khôi phục lại lịch sử phiên bản hoàn chỉnh. Tác nhân phần mềm kéo các khai báo trạng thái mong muốn từ nguồn. Các nhân viên của Softare liên tục quan sát trạng thái hệ thống thực tế và cố gắng áp dụng trạng thái mong muốn. Nội dung Giới thiệu ArgoCD Triển khai Workload với ArgoCD Quản lý Workload trên ArgoCD "
},
{
	"uri": "//localhost:1313/vi/9-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Dọn dẹp tài nguyên Thực hiện xóa EKS Blueprints cd ~/environment/my-eks-blueprints\rcdk destroy --all Chọn y Truy cập CloudFormation console Chọn Stack để cần xóa. Sau đó, chọn Delete "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]